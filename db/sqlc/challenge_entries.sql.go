// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: challenge_entries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createChallengeEntry = `-- name: CreateChallengeEntry :one
INSERT INTO challenge_entries (
  challenge_id,
  user_id
) VALUES (
  $1, $2
)
RETURNING id, challenge_id, user_id, date, completed, created_at
`

type CreateChallengeEntryParams struct {
	ChallengeID pgtype.UUID `json:"challenge_id"`
	UserID      pgtype.UUID `json:"user_id"`
}

func (q *Queries) CreateChallengeEntry(ctx context.Context, arg CreateChallengeEntryParams) (ChallengeEntry, error) {
	row := q.db.QueryRow(ctx, createChallengeEntry, arg.ChallengeID, arg.UserID)
	var i ChallengeEntry
	err := row.Scan(
		&i.ID,
		&i.ChallengeID,
		&i.UserID,
		&i.Date,
		&i.Completed,
		&i.CreatedAt,
	)
	return i, err
}

const deleteChallengeEntry = `-- name: DeleteChallengeEntry :one
DELETE FROM challenge_entries
WHERE id = $1
RETURNING id, challenge_id, user_id, date, completed, created_at
`

func (q *Queries) DeleteChallengeEntry(ctx context.Context, id pgtype.UUID) (ChallengeEntry, error) {
	row := q.db.QueryRow(ctx, deleteChallengeEntry, id)
	var i ChallengeEntry
	err := row.Scan(
		&i.ID,
		&i.ChallengeID,
		&i.UserID,
		&i.Date,
		&i.Completed,
		&i.CreatedAt,
	)
	return i, err
}

const getChallengeEntry = `-- name: GetChallengeEntry :one
SELECT id, challenge_id, user_id, date, completed, created_at FROM challenge_entries
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetChallengeEntry(ctx context.Context, id pgtype.UUID) (ChallengeEntry, error) {
	row := q.db.QueryRow(ctx, getChallengeEntry, id)
	var i ChallengeEntry
	err := row.Scan(
		&i.ID,
		&i.ChallengeID,
		&i.UserID,
		&i.Date,
		&i.Completed,
		&i.CreatedAt,
	)
	return i, err
}

const listChallengeEntries = `-- name: ListChallengeEntries :many
SELECT id, challenge_id, user_id, date, completed, created_at FROM challenge_entries
ORDER BY created_at
LIMIT $1
OFFSET $2
`

type ListChallengeEntriesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListChallengeEntries(ctx context.Context, arg ListChallengeEntriesParams) ([]ChallengeEntry, error) {
	rows, err := q.db.Query(ctx, listChallengeEntries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChallengeEntry
	for rows.Next() {
		var i ChallengeEntry
		if err := rows.Scan(
			&i.ID,
			&i.ChallengeID,
			&i.UserID,
			&i.Date,
			&i.Completed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChallengeEntry = `-- name: UpdateChallengeEntry :exec
UPDATE challenge_entries
  set completed = $2
WHERE id = $1
`

type UpdateChallengeEntryParams struct {
	ID        pgtype.UUID `json:"id"`
	Completed pgtype.Bool `json:"completed"`
}

func (q *Queries) UpdateChallengeEntry(ctx context.Context, arg UpdateChallengeEntryParams) error {
	_, err := q.db.Exec(ctx, updateChallengeEntry, arg.ID, arg.Completed)
	return err
}
