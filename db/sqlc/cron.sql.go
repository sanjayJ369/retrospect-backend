// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: cron.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTaskDaysForUsersInTimezone = `-- name: CreateTaskDaysForUsersInTimezone :exec
INSERT INTO task_days (user_id, date)
SELECT id, (NOW() AT TIME ZONE $1)::date
FROM users
WHERE timezone = $1
ON CONFLICT (user_id, date) DO NOTHING
`

// Creates new task_day entries for all users in a given timezone for their "today".
// The `(NOW() AT TIME ZONE $1)::date` correctly calculates the user's current date.
func (q *Queries) CreateTaskDaysForUsersInTimezone(ctx context.Context, timezone pgtype.Interval) error {
	_, err := q.db.Exec(ctx, createTaskDaysForUsersInTimezone, timezone)
	return err
}

const getTimezonesWhereDayIsStarting = `-- name: GetTimezonesWhereDayIsStarting :many
SELECT DISTINCT timezone FROM users
WHERE EXTRACT(HOUR FROM (NOW() AT TIME ZONE timezone)) = 0
`

// Finds all distinct timezones where the current local time is at the beginning of a new day (e.g., 00:00 to 00:59).
// We can then find all users for these timezones.
func (q *Queries) GetTimezonesWhereDayIsStarting(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getTimezonesWhereDayIsStarting)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var timezone string
		if err := rows.Scan(&timezone); err != nil {
			return nil, err
		}
		items = append(items, timezone)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
